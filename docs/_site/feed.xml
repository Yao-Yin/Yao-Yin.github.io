<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yao Yin's Cyberspace</title>
    <description>Yao Yin's Personal Website</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 03 Jul 2021 19:03:28 +0900</pubDate>
    <lastBuildDate>Sat, 03 Jul 2021 19:03:28 +0900</lastBuildDate>
    <generator>Jekyll v3.9.0</generator>
    
      <item>
        <title>CS144 Lab 2</title>
        <description>&lt;p&gt;上一个实验：&lt;a href=&quot;/cs144/2021/06/20/cs144-lab-1/&quot;&gt;Lab 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇文章会讲解 &lt;a href=&quot;https://cs144.github.io/&quot;&gt;CS144&lt;/a&gt; Lab 2 的思路和代码。&lt;/p&gt;

&lt;h1 id=&quot;lab-2&quot;&gt;Lab 2&lt;/h1&gt;

&lt;p&gt;这个 Lab 的目标是写一个 TCP receiver，它支持三个功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以接受一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCPSegment&lt;/code&gt;，并把其中的数据传给上一个 Lab 实现的 StreamReassembler；&lt;/li&gt;
  &lt;li&gt;支持查询 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ackno&lt;/code&gt;，也就是被排列好的最后一个字符的序数 +1；&lt;/li&gt;
  &lt;li&gt;支持查询 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;window_size&lt;/code&gt;，也就是滑动窗口里剩下的空间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git merge origin/lab2-startercode&lt;/code&gt; 合并 Lab 2 的代码后，我们就可以开始啦。&lt;/p&gt;

&lt;h2 id=&quot;translating-between-64-bit-indexes-and-32-bit-seqnos&quot;&gt;Translating between 64-bit indexes and 32-bit seqnos&lt;/h2&gt;

&lt;p&gt;为了达成这三个目的，我们需要先弄清楚这三个序数的定义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sequence Numbers, 记为 SN&lt;/li&gt;
  &lt;li&gt;Absolute Sequence Numbers，记为 ASN&lt;/li&gt;
  &lt;li&gt;Stream Indices，记为 SI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这三个数的定义在原文档我就不复制了，简单说一下他们的关系：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SN = (ASN + ISN) &amp;amp; (0xFFFFFFFF) （取最低32位）&lt;/li&gt;
  &lt;li&gt;SI = ASN - 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们还需要一个把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WrappingInt32&lt;/code&gt; 转换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uint54_t&lt;/code&gt; 的转换函数：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uint64_t wrappingInt32_to_uint64(WrappingInt32 n) { 
    return static_cast&amp;lt;uint64_t&amp;gt;(n.raw_value()); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在它的帮助下，我们可以写出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wrap&lt;/code&gt; 函数：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;WrappingInt32 wrap(uint64_t n, WrappingInt32 isn) {
    uint64_t res = n + wrappingInt32_to_uint64(isn);
    res &amp;amp;= 0xFFFFFFFF;
    return WrappingInt32{static_cast&amp;lt;uint32_t&amp;gt;(res)};
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unwrap&lt;/code&gt; 函数稍微复杂一些。由于 CS144 lab 都是有测试例的，所以即使一些方法可以帮助我们完成主要目标（指实现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCPReceiver&lt;/code&gt;），但想完成 Lab 的话不能绕过这些测试例。比如这里，其实我们可以返回比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkpoint&lt;/code&gt; 大的最小满足条件的数，但是由于 Lab 已经规定好了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unwrap&lt;/code&gt; 是寻找最接近的数，因此还是得按要求来。参考代码如下:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) {
    uint64_t res = wrappingInt32_to_uint64(n) - wrappingInt32_to_uint64(isn);
    res &amp;amp;= 0xFFFFFFFF;
    uint64_t first_part = checkpoint &amp;amp; 0xFFFFFFFF00000000;
    res |= first_part;
    uint64_t alternative = res;
    if (res &amp;lt; checkpoint) {
        alternative = res + (1ul &amp;lt;&amp;lt; 32);
        return alternative - checkpoint &amp;gt;= checkpoint - res ? res : alternative;
    } else if (res &amp;gt; checkpoint) {
        if (res &amp;lt; (1ul &amp;lt;&amp;lt; 32))
            return res;
        alternative = res - (1ul &amp;lt;&amp;lt; 32);
        return checkpoint - alternative &amp;gt;= res - checkpoint ? res : alternative;
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这部分可以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build&lt;/code&gt; 目录下编译并测试，和之前类似：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ CXX=g++-8 cmake ..
$ make format
$ make -j4
$ ctest -R wrap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过的话会得到类似字样：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;100% tests passed, 0 tests failed out of 4

Total Test time (real) =   0.14 sec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这些函数的帮助下，我们可以开始实现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCPreceiver&lt;/code&gt; 了。&lt;/p&gt;

&lt;h3 id=&quot;implementing-the-tcp-receiver&quot;&gt;Implementing the TCP receiver&lt;/h3&gt;

&lt;p&gt;正如同文档所说，这个 Lab 没有什么需要构造的数据结构，但是我们需要对很多数值的定义小心。
由于 ISN 指代的是 SYN 的 SN，所以除了第一个带有 SYN 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCPsegment&lt;/code&gt; 以外，在我们计算其他的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCPSegment&lt;/code&gt; 的 payload 对应的 SI 时，都需要减一。另外需要注意的是如果没有收到 SYN 信号的话，我们应该抛弃所有的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCPSegment&lt;/code&gt;，因为这个时候我们的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCPReceiver&lt;/code&gt; 还没准备好接受分段，这里我们维护变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;initFlag&lt;/code&gt; 来记载是否接收到了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;参考代码：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void TCPReceiver::segment_received(const TCPSegment &amp;amp;seg) {
    if (seg.header().syn) {
        // initialize ISN
        ISN = seg.header().seqno;
        initFlag = true;
    } else if (!initFlag) {
        return;
    }
    size_t stream_idx = unwrap(seg.header().seqno, ISN, _reassembler.stream_out().bytes_written());
    if (!seg.header().syn)
        stream_idx -= 1;
    _reassembler.push_substring(seg.payload().copy(), stream_idx, seg.header().fin);
}

optional&amp;lt;WrappingInt32&amp;gt; TCPReceiver::ackno() const {
    size_t abs_idx = _reassembler.stream_out().bytes_written();
    if (!initFlag)
        return {};
    abs_idx++;
    if (_reassembler.stream_out().input_ended())
        abs_idx++;
    return wrap(abs_idx, ISN);
}

size_t TCPReceiver::window_size() const { 
    return _reassembler.stream_out().remaining_capacity(); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;完成后我们在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build&lt;/code&gt;目录下编译并测试，和之前类似：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ CXX=g++-8 cmake ..
$ make format
$ make -j4
$ make check_lab2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过的话会得到类似字样：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;100% tests passed, 0 tests failed out of 26

Total Test time (real) =   0.82 sec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/cs144/2021/07/03/cs144-lab-2/</link>
        <guid isPermaLink="true">http://localhost:4000/cs144/2021/07/03/cs144-lab-2/</guid>
        
        <category>CS144</category>
        
        <category>computer networking</category>
        
        
        <category>CS144</category>
        
      </item>
    
      <item>
        <title>CS144 Lab 1</title>
        <description>&lt;p&gt;上一个实验：&lt;a href=&quot;/cs144/2021/05/29/cs144-lab-0/&quot;&gt;Lab 0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇文章会讲解 &lt;a href=&quot;https://cs144.github.io/&quot;&gt;CS144&lt;/a&gt; 在 vscode 上的 GDB 配置以及 Lab 1 的思路和代码。&lt;/p&gt;

&lt;h1 id=&quot;gdb-配置&quot;&gt;GDB 配置&lt;/h1&gt;

&lt;p&gt;在 Lab 0 里我们不需要使用 GDB debug，但是在 Lab 1 里我们需要，这里是我配置 GDB 的办法，来源&lt;a href=&quot;https://segmentfault.com/a/1190000039087458&quot;&gt;wine99 的博客&lt;/a&gt;，结合自己的系统情况修改了一下。首先将 Lab 0 的分支代码 merge 到 Lab 1 的对应分支里。然后当前 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sponge&lt;/code&gt; 文件夹内，新建一个名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vscode&lt;/code&gt; 的文件夹，其中里面有四个 json 文件，分别是：&lt;/p&gt;

&lt;p&gt;c_cpp_properties:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;Linux&quot;,
            &quot;includePath&quot;: [
                &quot;${workspaceFolder}/**&quot;,
                &quot;${workspaceFolder}/libsponge/**&quot;
            ],
            &quot;defines&quot;: [],
            &quot;compilerPath&quot;: &quot;/usr/bin/g++-8&quot;,
            &quot;cStandard&quot;: &quot;c11&quot;,
            &quot;intelliSenseMode&quot;: &quot;linux-clang-x64&quot;,
            &quot;compileCommands&quot;: &quot;${workspaceFolder}/build/compile_commands.json&quot;
        }
    ],
    &quot;version&quot;: 4
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;launch.json:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;debug lab test&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/build/tests/${fileBasenameNoExtension}&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                }
            ],
            &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;
        },
        {
            &quot;name&quot;: &quot;debug webget&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/build/apps/webget&quot;,
            &quot;args&quot;: [&quot;cs144.keithw.org&quot;, &quot;/hello&quot;],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                }
            ],
            // &quot;preLaunchTask&quot;: &quot;C/C++: g++ build active file&quot;,
            &quot;preLaunchTask&quot;: &quot;build project&quot;,
            &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;
        },
        {
            &quot;name&quot;: &quot;debug current file&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                }
            ],
            &quot;preLaunchTask&quot;: &quot;C/C++: g++ build active file&quot;,
            &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;settings.json:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;debug.allowBreakpointsEverywhere&quot;: true,
    &quot;files.associations&quot;: {
        &quot;chrono&quot;: &quot;cpp&quot;,
        &quot;random&quot;: &quot;cpp&quot;,
        &quot;limits&quot;: &quot;cpp&quot;,
        &quot;algorithm&quot;: &quot;cpp&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;tasks.json:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;tasks&quot;: [
        {
            &quot;type&quot;: &quot;shell&quot;,
            &quot;label&quot;: &quot;C/C++: g++ build active file&quot;,
            &quot;command&quot;: &quot;/usr/bin/g++-8&quot;,
            &quot;args&quot;: [
                &quot;-g&quot;,
                &quot;${file}&quot;,
                &quot;-o&quot;,
                &quot;${fileDirname}/${fileBasenameNoExtension}&quot;
            ],
            &quot;options&quot;: {
                &quot;cwd&quot;: &quot;${workspaceFolder}&quot;
            },
            &quot;problemMatcher&quot;: [
                &quot;$gcc&quot;
            ],
            &quot;group&quot;: {
                &quot;kind&quot;: &quot;build&quot;,
                &quot;isDefault&quot;: true
            }
        },
        {
            &quot;type&quot;: &quot;shell&quot;,
            &quot;label&quot;: &quot;build project&quot;,
            &quot;command&quot;: &quot;cd build &amp;amp;&amp;amp; make -j8&quot;,
            &quot;args&quot;: [],
        },
    ],
    &quot;version&quot;: &quot;2.0.0&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在配置好这些文件之后，我们就可以愉快地（并不）使用 GDB debug 了。&lt;/p&gt;

&lt;h1 id=&quot;lab-1&quot;&gt;Lab 1&lt;/h1&gt;

&lt;p&gt;这个 Lab 的目标是写一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StreamReassembler&lt;/code&gt;，它接受一些字符串和对应的 index，这里的 index 是字符串的第一个字符在 TCP 字节流的位置（起始值为0），按顺序拼好并传递给 Lab 0 实现的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ByteStream&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;getting-started&quot;&gt;Getting started&lt;/h2&gt;

&lt;p&gt;在开始写代码前，我们需要定义清楚一些问题，可以避免一些踩坑（我一开始没这么做，导致第一次快写完的时候整个重写了）。常见的需要定义清楚的问题有这么几个：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q1：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unassembled bytes&lt;/code&gt; 是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：是还未传递但是要传递给 ByteStream 的储存在 StreamReassembler 的字符数，其中如果不同的字符串有重叠部分的话，重叠部分只算一次；&lt;/p&gt;

&lt;p&gt;举个例子，假设我们有两个字符串，一个是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Happy&lt;/code&gt;，它的 index 是 0，另一个是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py anniversary&lt;/code&gt;，它的 index 是 3，那么可想而知，整个算下来应该是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Happy anniversary&lt;/code&gt;，此时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unassembled bytes&lt;/code&gt; 值为17。&lt;/p&gt;

&lt;p&gt;再举个例子，假设我们还是有两个字符串，一个是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ha&lt;/code&gt;，它的 index 是 0，另一个是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y anniversary&lt;/code&gt;, 它的 index 是 3，此时的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unassembled bytes&lt;/code&gt; 值为 15，因为整个算下来是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ha??y anniversary&lt;/code&gt;，我们不知道也没有存 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;??&lt;/code&gt; 位置的字符，所以这两个位置是不计数的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q2：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capacity&lt;/code&gt; 是对什么容量的限制？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：文档里的图解释的挺清楚的，我这里再复述一遍，是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StreamReassembler&lt;/code&gt; 里储存的 index 最大的字符的 index 减去在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ByteStream&lt;/code&gt; 里还没有被读取的 index 最小的字符的 index 的上限加一，说起来有点弯弯绕，结合下面这个例子会比较好。&lt;/p&gt;

&lt;p&gt;假设 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ByteStream&lt;/code&gt; 里还未读取的字符是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Happy&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StreamReassembler&lt;/code&gt; 里只有一个字符串，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ver&lt;/code&gt;，它的index 是 10，那么此时它占据的容量是 13，因为组合到一起，是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Happy?????ver&lt;/code&gt;，尽管我们不知道 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?????&lt;/code&gt; 的内容，但是我们要为之预留空间。推广一下，如果读取的字符串有一部分超过了我们能接受的最大容量，即使我们有足够的内存，也要舍弃它，因为超出了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capacity&lt;/code&gt; 的限制。&lt;/p&gt;

&lt;h2 id=&quot;design-the-core-data-structures&quot;&gt;Design the core data structures&lt;/h2&gt;

&lt;p&gt;就这个 Lab 来讲，我们需要一个数据结构来维护没有读取的字符串，并且这些字符串是有序的（index），其实我一开始的想法是用堆，完成并 debug 后过了绝大部分的测试例，只有关于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unassembled bytes&lt;/code&gt; 的测试有问题，仔细研究定义（如上）后，决定推倒重新写。&lt;/p&gt;

&lt;p&gt;我们需要一个容器，可以容纳来自同一个字节流的字符串，并且我们需要跟踪字符数目，权衡之后我选择用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::deque&amp;lt;char&amp;gt; _unassembled_bytes&lt;/code&gt; 来维护所有未传输给 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ByteStream&lt;/code&gt; 的字符。如果这个队列空间不够存下下一个字符串的话，我们就扩大它，在整体不超过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capacity&lt;/code&gt; 的限制下存下尽量多的字符。这里问题来了，我们还需要思考，这个队列里存放的字符是不是已经读取的字符，比如我们读了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Happy?????ver&lt;/code&gt;，这些 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt; 要如何表示，一开始我的想法是用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'\0'&lt;/code&gt; 表示，后来觉得如果字节流里有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'\0'&lt;/code&gt; 就不行，因此选用了另一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::deque&amp;lt;bool&amp;gt; _pos_checker&lt;/code&gt;  来记录 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_unassembled_bytes&lt;/code&gt; 对应位置的字节是否是已经读取的字符，他们被同步更新，并且 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_pos_checker&lt;/code&gt; 里 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 的数量就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unassembled bytes&lt;/code&gt; 的数值。&lt;/p&gt;

&lt;p&gt;以下是一个更新字符串的实现：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void StreamReassembler::update_unassembled_bytes(const string &amp;amp;data, const size_t index) {
    size_t start_data_idx = max(0, static_cast&amp;lt;int&amp;gt;(_idx) - static_cast&amp;lt;int&amp;gt;(index));
    _max_idx = max(_max_idx, index + data.size());
    size_t target_right_bound = min(index + data.size(), _capacity - _output.buffer_size() + _idx);
    if (target_right_bound &amp;gt; _right_bound) {
        // no space, need to expand it
        for (size_t i = 0; i &amp;lt; target_right_bound - _right_bound; i++) {
            _unassembled_bytes.push_back('\0');
            _pos_checker.push_back(false);
        }
        _right_bound = target_right_bound;
    }
    size_t start_deque_idx = start_data_idx + index - _idx;
    for (size_t i = 0; i + start_data_idx &amp;lt; data.size() &amp;amp;&amp;amp; i + start_deque_idx &amp;lt; _pos_checker.size(); i++) {
        _unassembled_bytes[i + start_deque_idx] = data[i + start_data_idx];
        if (!_pos_checker[i + start_deque_idx])
            _unassembled_bytes_cnt++;
        _pos_checker[i + start_deque_idx] = true;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里有一些变量需要解释：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_idx&lt;/code&gt;：deque 里第一个位置对应的 index&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_unassembled_bytes_cnt&lt;/code&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unassembled bytes&lt;/code&gt; 的数值&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_right_bound&lt;/code&gt;：deque 能储存的字符的最大 index 加一（恰好不能储存的序数）&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_max_idx&lt;/code&gt;：已经得知存在的字符串最后一个字符的最大 index 加一，用来确定是否已经结束输入。假设我们的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StreamReassembler&lt;/code&gt; 要读取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Happy anniversary&lt;/code&gt;，且 index 为 0，可是由于容量限制，我们只能读取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Happy anniversar&lt;/code&gt;，由于最后一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt; 是存在的，我们只是暂时存不下，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_max_idx&lt;/code&gt; 就是这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt; 对应的的 index 值，这个可以用来判断是否要给 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ByteStream&lt;/code&gt; 传递输入结束的信号，不太好理解的话可以先跳过，看后续代码就清楚了。&lt;/p&gt;

&lt;h2 id=&quot;implement-the-whole-class&quot;&gt;Implement the whole class&lt;/h2&gt;

&lt;p&gt;由于我们的逻辑是尽可能地将字符传递给 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ByteStream _output&lt;/code&gt;，所以每次更新后都要尽量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;参考实现如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void StreamReassembler::push_substring(const string &amp;amp;data, const size_t index, const bool eof) {
    update_unassembled_bytes(data, index);
    // read
    while (_output.remaining_capacity() &amp;amp;&amp;amp; !_unassembled_bytes.empty() &amp;amp;&amp;amp; _pos_checker.front()) {
        char curr = _unassembled_bytes.front();
        string to_write(1, curr);
        _unassembled_bytes.pop_front();
        _pos_checker.pop_front();
        _output.write(to_write);
        _idx++;
        _unassembled_bytes_cnt --;
    }
    if (eof) {
        _eof = true;
    }
    if (_eof &amp;amp;&amp;amp; _idx == _max_idx) {
        _output.end_input();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其他函数代码：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;size_t StreamReassembler::unassembled_bytes() const { return _unassembled_bytes_cnt; }

bool StreamReassembler::empty() const { return unassembled_bytes() == 0; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;完成后我们在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build&lt;/code&gt; 目录下编译并测试，和之前类似：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ CXX=g++-8 cmake ..
$ make format
$ make -j4
$ make check_lab1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过的话会得到类似字样：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;100% tests passed, 0 tests failed out of 16

Total Test time (real) =   0.66 sec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下一个实验：&lt;a href=&quot;/cs144/2021/07/03/cs144-lab-2/&quot;&gt;Lab 2&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/cs144/2021/06/20/cs144-lab-1/</link>
        <guid isPermaLink="true">http://localhost:4000/cs144/2021/06/20/cs144-lab-1/</guid>
        
        <category>CS144</category>
        
        <category>computer networking</category>
        
        
        <category>CS144</category>
        
      </item>
    
      <item>
        <title>CS144 Lab 0</title>
        <description>&lt;p&gt;这篇文章会讲解 &lt;a href=&quot;https://cs144.github.io/&quot;&gt;CS144&lt;/a&gt; 的实验环境配置以及 Lab 0 的思路和代码。&lt;/p&gt;

&lt;h1 id=&quot;环境配置&quot;&gt;环境配置&lt;/h1&gt;

&lt;p&gt;我是在 WSL2 下做 Lab 的，首先需要参照这个&lt;a href=&quot;https://stanford.edu/class/cs144/vm_howto/vm-howto-byo.html&quot;&gt;清单&lt;/a&gt;下载好所有依赖，基本上就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo apt-get install &amp;lt;dependency&amp;gt;&lt;/code&gt;，不太确定的话请谷歌。&lt;/p&gt;

&lt;p&gt;另一部分的配置是在 github 把&lt;a href=&quot;https://github.com/CS144/sponge&quot;&gt;官方仓库&lt;/a&gt;克隆进自己的一个私有仓库，可以参照 &lt;a href=&quot;https://stackoverflow.com/questions/10065526/github-how-to-make-a-fork-of-public-repository-private&quot;&gt;stackoverflow&lt;/a&gt; 完成。之前看到有其他网友因为设置成了公开被这门课的教授要求改成私人可见，所以感觉还是不要麻烦别人比较好。这步不用着急，在 Lab 0 文档的第三部分有指导。&lt;/p&gt;

&lt;h1 id=&quot;lab-0&quot;&gt;Lab 0&lt;/h1&gt;

&lt;h2 id=&quot;networking-by-hand&quot;&gt;Networking by hand&lt;/h2&gt;

&lt;p&gt;第一步是获取一个网页，这里有个小坑就是在命令行输入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;telnet cs144.keithw.org http&lt;/code&gt; 之后，会进入 command 模式，没办法输入多行，需要按 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctrl + ]&lt;/code&gt; 进入 client 模式，这样可以输入多行，可以参照&lt;a href=&quot;https://serverfault.com/questions/493313/telnet-doesnt-accept-enter-as-a-newline&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;第二步是用命令行发封 email，由于咱们没有斯坦福的账号，所以需要用个人邮箱，可以谷歌搜索 &lt;strong&gt;SMTP&lt;/strong&gt; 来了解相关设置，具体怎么做就略了。&lt;/p&gt;

&lt;p&gt;第三步按照&lt;a href=&quot;https://cs144.github.io/assignments/lab0.pdf&quot;&gt;文档&lt;/a&gt;开两个 WSL 命令行窗口输指令就好，也略了。&lt;/p&gt;

&lt;h2 id=&quot;writing-a-network-program-using-an-os-stream-socket&quot;&gt;Writing a network program using an OS stream socket&lt;/h2&gt;

&lt;h3 id=&quot;get-started&quot;&gt;Get started&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmake ..&lt;/code&gt; 可能需要替换成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CXX=g++-8 cmake ..&lt;/code&gt;，别的没啥坑。&lt;/p&gt;

&lt;h3 id=&quot;writing-webget&quot;&gt;Writing webget&lt;/h3&gt;

&lt;p&gt;这部分是需要实现 &lt;strong&gt;../apps/webget.cc&lt;/strong&gt; 里的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;void get_URL(const string &amp;amp;host, const string &amp;amp;path)&lt;/code&gt; 这个函数，这个函数的目的是新建一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCPSocket&lt;/code&gt;，将其与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;host&lt;/code&gt; 连接，发送对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt; 路径下内容的请求，并将返回内容打印到标准输出。&lt;/p&gt;

&lt;p&gt;首先需要阅读 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FileDescriptor&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Socket&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCPSocket&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Address&lt;/code&gt; 的文档。阅读之后我们可以很容易地写出代码，参考如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void get_URL(const string &amp;amp;host, const string &amp;amp;path) { 
    TCPSocket socket{};
    socket.connect(Address(host, &quot;http&quot;));
    string httpRequest = &quot;GET &quot; + path + &quot; HTTP/1.1\r\n&quot; + &quot;Host: &quot; + host + &quot;\r\n&quot; + &quot;Connection: close\r\n\r\n&quot;;
    socket.write(httpRequest);
    while (!socket.eof()) {
        auto &amp;amp;&amp;amp;response = socket.read();
        cout &amp;lt;&amp;lt; response;
    }
    socket.close();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;an-in-memory-reliable-byte-stream&quot;&gt;An in-memory reliable byte stream&lt;/h3&gt;

&lt;p&gt;这一部分需要我们实现一个可靠的双向字节流。我用了一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::deque&amp;lt;char&amp;gt; buf&lt;/code&gt; 来做存储的核心数据结构，但实际上其他 FIFO 满足 O(1) 单个字符输入输出的结构都行。实验设计美中不足的是没有规定阅读超过储存大小的行文以及单次输入超过最大容量的字符串的行为。&lt;/p&gt;

&lt;p&gt;除了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buf&lt;/code&gt; 之外我还用了几个变量来储存一些信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size_t MAX_CAPACITY&lt;/code&gt; 用来设定最大容量&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size_t REMAIN_CAPACITY&lt;/code&gt; 用来记录剩余容量&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size_t _byte_written&lt;/code&gt; 用来记录一共写入的字符数，注意这个是包括读取后，现在不在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buf&lt;/code&gt; 里的字符数的，是历史写入的总和&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size_t _byte_read&lt;/code&gt; 用来记录一共读取的字符数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bool _input_ended&lt;/code&gt; 用来记录是否已经输入完成了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几个核心的函数实现如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ByteStream::ByteStream(const size_t capacity) {
    MAX_CAPACITY = capacity;
    REMAIN_CAPACITY = capacity;
}

size_t ByteStream::write(const string &amp;amp;data) {
    size_t byteCount = 0;
    for (auto &amp;amp;&amp;amp;c : data) {
        if (REMAIN_CAPACITY == 0) {
            set_error();
            return byteCount;
        }
        buf.push_back(c);
        byteCount++;
        _byte_written++;
        REMAIN_CAPACITY--;
    }
    return byteCount;
}

string ByteStream::peek_output(const size_t len) const {
    string res;
    for (auto &amp;amp;&amp;amp;iter = buf.cbegin(); iter &amp;lt; buf.cbegin() + len; iter++) {
        res.push_back(*iter);
    }
    return res;
}

void ByteStream::pop_output(const size_t len) {
    for (size_t i = 0; i &amp;lt; len; i++) {
        buf.pop_front();
        _byte_read++;
    }
    REMAIN_CAPACITY += len;
}

std::string ByteStream::read(const size_t len) {
    string res;
    for (size_t i = 0; i &amp;lt; len; i++) {
        res.push_back(buf.front());
        buf.pop_front();
        REMAIN_CAPACITY++;
        _byte_read++;
    }
    return res;
}

bool ByteStream::eof() const { 
    // 虽然感觉文档的 eof 定义不够准确，但这样可以过测试
    return buffer_empty() &amp;amp;&amp;amp; input_ended(); 
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;基本上还是比较直白的，不需要太多介绍。
实现完之后可以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build&lt;/code&gt; 目录下通过以下命令来编译并测试自己的代码：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ CXX=g++-8 cmake ..
$ make format
$ make -j4
$ make check_lab0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过的话会得到类似字样：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;100% tests passed, 0 tests failed out of 9

Total Test time (real) =   1.36 sec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下一个实验：&lt;a href=&quot;/cs144/2021/06/20/cs144-lab-1/&quot;&gt;Lab 1&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 29 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/cs144/2021/05/29/cs144-lab-0/</link>
        <guid isPermaLink="true">http://localhost:4000/cs144/2021/05/29/cs144-lab-0/</guid>
        
        <category>CS144</category>
        
        <category>computer networking</category>
        
        
        <category>CS144</category>
        
      </item>
    
      <item>
        <title>My Journey in Computer Science and Math</title>
        <description>&lt;p&gt;Just as I writed in &lt;a href=&quot;/biography/2021/05/14/about-me/&quot;&gt;&lt;em&gt;About Me&lt;/em&gt;&lt;/a&gt;, I love the world of CS and math and I taught myself bits of knowledge in these fields and use them to pass the entrance exam of UTokyo and to be hired as a software engineer. This post is about what I did and what I will do in the future.&lt;/p&gt;

&lt;p&gt;I got my bachelor’s degree in pharmacy but I decided to quit that in the 4th year of my undergraduate studies. Thus I have no extra time to persue anthor bacholer’s degree in computer science/math/software engineering. With generous seggestions from one of my good friends who is a Google software engineer now, I decided to learn open source computer science courses.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;201831--2019331&quot;&gt;2018.3.1 ~ 2019.3.31&lt;/h2&gt;

&lt;p&gt;The entrance examination of computational biology department in UTokyo needs calculus, linear algebra, graph theory, data structures, algorithms, probability, statistics and stochastic processes. In order to pass the examination, I spent most of time on math courses.&lt;/p&gt;

&lt;h3 id=&quot;calculus&quot;&gt;Calculus&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Calculus courses in Nankai University&lt;/li&gt;
  &lt;li&gt;Review it by &lt;a href=&quot;https://book.douban.com/subject/2025549/&quot;&gt;this book&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;linear-algebra&quot;&gt;Linear Algebra&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/&quot;&gt;MIT 18.06&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Practice problems from &lt;a href=&quot;https://www.amazon.co.jp/%E6%BC%94%E7%BF%92-%E5%A4%A7%E5%AD%A6%E9%99%A2%E5%85%A5%E8%A9%A6%E5%95%8F%E9%A1%8C-%E6%95%B0%E5%AD%A6-%E5%A7%AB%E9%87%8E-%E4%BF%8A%E4%B8%80/dp/478191361X&quot;&gt;the little yellow book i&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Read some chapters from &lt;a href=&quot;https://linear.axler.net/&quot;&gt;&lt;em&gt;Linear Algebra Done Right&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;differential-equations&quot;&gt;Differential Equations&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ocw.mit.edu/courses/mathematics/18-03-differential-equations-spring-2010/&quot;&gt;MIT 18.03&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;probability&quot;&gt;Probability&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Coursera courses (&lt;a href=&quot;https://zh.coursera.org/learn/prob1&quot;&gt;i&lt;/a&gt;, &lt;a href=&quot;https://zh.coursera.org/learn/prob2&quot;&gt;ii&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;First half of &lt;a href=&quot;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-041-probabilistic-systems-analysis-and-applied-probability-fall-2010/&quot;&gt;MIT 6.041&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Practice problems from &lt;a href=&quot;https://www.amazon.co.jp/-/en/%E5%A7%AB%E9%87%8E-%E4%BF%8A%E4%B8%80/dp/4781913717/ref=pd_lpo_14_t_0/356-4596967-6851831?_encoding=UTF8&amp;amp;pd_rd_i=4781913717&amp;amp;pd_rd_r=0a1217f4-6984-4c97-a56e-5da767cebea1&amp;amp;pd_rd_w=c2JPG&amp;amp;pd_rd_wg=VzFDT&amp;amp;pf_rd_p=dc0198fa-c371-4787-b1e2-96ed0e4d45e8&amp;amp;pf_rd_r=0XRTYSGETW6N8X5W01JN&amp;amp;psc=1&amp;amp;refRID=0XRTYSGETW6N8X5W01JN&quot;&gt;the little yellow book ii&lt;/a&gt; and homeworks of &lt;a href=&quot;https://projects.iq.harvard.edu/stat110/home&quot;&gt;Harvard STAT 110&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;statistics&quot;&gt;Statistics&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=dgG9Q7VyRb0&quot;&gt;Statistic courses&lt;/a&gt; from NCTU&lt;/li&gt;
  &lt;li&gt;Practice problems from above course and &lt;a href=&quot;https://www.amazon.co.jp/-/en/%E5%A7%AB%E9%87%8E-%E4%BF%8A%E4%B8%80/dp/4781913717/ref=pd_lpo_14_t_0/356-4596967-6851831?_encoding=UTF8&amp;amp;pd_rd_i=4781913717&amp;amp;pd_rd_r=0a1217f4-6984-4c97-a56e-5da767cebea1&amp;amp;pd_rd_w=c2JPG&amp;amp;pd_rd_wg=VzFDT&amp;amp;pf_rd_p=dc0198fa-c371-4787-b1e2-96ed0e4d45e8&amp;amp;pf_rd_r=0XRTYSGETW6N8X5W01JN&amp;amp;psc=1&amp;amp;refRID=0XRTYSGETW6N8X5W01JN&quot;&gt;the little yellow book ii&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;stochastic-processes&quot;&gt;Stochastic Processes&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Poisson process from &lt;a href=&quot;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-262-discrete-stochastic-processes-spring-2011/&quot;&gt;MIT 6.262&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Discrete Markov process from chapter 1 of &lt;a href=&quot;https://www.amazon.co.jp/Markov-Cambridge-Statistical-Probabilistic-Mathematics/dp/0521633966&quot;&gt;&lt;em&gt;Markov Chains&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;graph-theory&quot;&gt;Graph Theory&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Graph theory chapter of &lt;a href=&quot;https://book.douban.com/subject/1245789/&quot;&gt;this book&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Unit 1 &amp;amp; 2 of &lt;a href=&quot;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-spring-2015/index.htm&quot;&gt;MIT 6.042J&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;data-structures-and-algorithms&quot;&gt;Data Structures and Algorithms&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/&quot;&gt;MIT 6.006&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Part of &lt;a href=&quot;https://algs4.cs.princeton.edu/home/&quot;&gt;&lt;em&gt;Algorithms&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some other introduction to cs courses and programming language (python, C++) courses are not listed here. These are what I learned before I went to UTokyo (~2019.3). Following part are what I learned from 2019.4.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;201941--2021514&quot;&gt;2019.4.1 ~ 2021.5.14&lt;/h2&gt;

&lt;h3 id=&quot;machine-learning&quot;&gt;Machine Learning&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://speech.ee.ntu.edu.tw/~hylee/ml/2019-spring.html&quot;&gt;Machine learning course&lt;/a&gt; from Prof. Hung-yi Lee&lt;/li&gt;
  &lt;li&gt;Data mining course from Prof. Tsuda in UTokyo&lt;/li&gt;
  &lt;li&gt;Part of &lt;a href=&quot;https://book.douban.com/subject/26708119/&quot;&gt;watermelon book&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;deep-learning&quot;&gt;Deep Learning&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://cs231n.stanford.edu/2017/&quot;&gt;Stanford CS231n&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Part of &lt;a href=&quot;https://www.deeplearningbook.org/&quot;&gt;&lt;em&gt;Deep Learning&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;more-algorithms&quot;&gt;More Algorithms&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Algorithm courses from Prof. Hirai in UTokyo&lt;/li&gt;
  &lt;li&gt;Chapter 1~6 of &lt;a href=&quot;https://www.amazon.com/gp/product/0321295358/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;tag=kleinberg-tardos-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321295358&quot;&gt;&lt;em&gt;Algorithm Design&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Solved over 1000 problems on various Online Judges such as &lt;a href=&quot;https://leetcode.com/Yao_Yin/&quot;&gt;LeetCode&lt;/a&gt;, &lt;a href=&quot;https://atcoder.jp/users/Solored&quot;&gt;AtCoder&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;computer-system&quot;&gt;Computer System&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/&quot;&gt;CMU 15-213&lt;/a&gt; together with its labs on &lt;a href=&quot;https://github.com/yao-yin/CSAPP-labs&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I also got benefits from some courses without a university backround, like ones from &lt;a href=&quot;https://space.bilibili.com/7836741?from=search&amp;amp;seid=11413859523024460719&quot;&gt;yxc&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/channel/UCRPMAqdtSgd0Ipeef7iFsKw&quot;&gt;Gaurav Sen&lt;/a&gt;. Computational biology related books and courses are not listed here.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Here is my plan in the future.&lt;/p&gt;

&lt;h2 id=&quot;2021515-&quot;&gt;2021.5.15 ~&lt;/h2&gt;

&lt;h3 id=&quot;competitive-programming&quot;&gt;Competitive Programming&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;To solve all problems on &lt;a href=&quot;https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%82%B3%E3%83%B3%E3%83%86%E3%82%B9%E3%83%88%E3%83%81%E3%83%A3%E3%83%AC%E3%83%B3%E3%82%B8%E3%83%96%E3%83%83%E3%82%AF-%E7%AC%AC2%E7%89%88-%EF%BD%9E%E5%95%8F%E9%A1%8C%E8%A7%A3%E6%B1%BA%E3%81%AE%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E6%B4%BB%E7%94%A8%E5%8A%9B%E3%81%A8%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%83%86%E3%82%AF%E3%83%8B%E3%83%83%E3%82%AF%E3%82%92%E9%8D%9B%E3%81%88%E3%82%8B%EF%BD%9E-%E7%A7%8B%E8%91%89%E6%8B%93%E5%93%89/dp/4839941068&quot;&gt;&lt;em&gt;Ant book&lt;/em&gt;&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Currently solved all problems before &lt;a href=&quot;https://vjudge.net/article/46&quot;&gt;chapter 3.3&lt;/a&gt; (2021.5.15)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Solve another 1000 problems on various online judges
    &lt;ul&gt;
      &lt;li&gt;I wish to have a rating over 2000 on &lt;a href=&quot;https://atcoder.jp/&quot;&gt;AtCoder&lt;/a&gt;, currently around 1400 (2021.5.15)&lt;/li&gt;
      &lt;li&gt;I with to win a T-shirt on GCJ. To achieve this, I need to be qualified for GCJ R3, currently qualified for GCJ R2 (2021.5.15)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;operating-system&quot;&gt;Operating System&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pdos.csail.mit.edu/6.S081/2020/&quot;&gt;MIT 6.S081&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/yao-yin/xv6-labs-2020&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;computer-networking&quot;&gt;Computer Networking&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cs144.github.io/&quot;&gt;Stanford CS144&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Start from 2021.5.12&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/yao-yin/sponge&quot;&gt;Github&lt;/a&gt;, might be set to be private in the future if requested by course owners&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;database&quot;&gt;Database&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://15445.courses.cs.cmu.edu/fall2019/&quot;&gt;CMU 15-445&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Will start it if I finish two above courses&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;computer-architecture&quot;&gt;Computer Architecture&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://safari.ethz.ch/digitaltechnik/spring2020/doku.php?id=labs&quot;&gt;ETHZ Digital Design and Computer Architecture&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Wait my FPGA board to arrive (2021.5.15)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;compiler&quot;&gt;Compiler&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://web.stanford.edu/class/cs143/&quot;&gt;CS143&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;design-patterns&quot;&gt;Design Patterns&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Haven’t decided where to study it (2021.5.15).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I am also interested in other criteria such as distributed systems, but most of them need above courses as prerequite. I’ll think about it after I finish the above courses.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;By the way, I believe all of the courses above can cover requirements of a bachelor’s degree in computer science engineering, so I call it “yy的补全计划” (YY’s completion plan). If you see this word in some other place, that should be me.&lt;/p&gt;

&lt;p&gt;At the very beginning of this plan, I wished to finish it before 2022.9, after changing some contents of it and becoming a fulltime software engineer, I found that most of energy will be taken to do my job and I would like to spend much more time with my dear girlfriend. Thus pushing myself crucially is meaningless. I wanna enjoy my job, enjoy my life, enjoy these courses. I don’t want to be burnt out. My estimation on the date that I finish these courses is 2023.3, a traditional graduation season in Japan.&lt;/p&gt;

&lt;p&gt;頑張ります!&lt;/p&gt;
</description>
        <pubDate>Fri, 14 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biography/2021/05/14/my-journey-in-cs-and-math/</link>
        <guid isPermaLink="true">http://localhost:4000/biography/2021/05/14/my-journey-in-cs-and-math/</guid>
        
        <category>biography</category>
        
        <category>computer science</category>
        
        <category>math</category>
        
        <category>learning plan</category>
        
        
        <category>biography</category>
        
      </item>
    
      <item>
        <title>About Me</title>
        <description>&lt;p&gt;Hi, I am Yao Yin, a software engineer based in Tokyo.&lt;/p&gt;

&lt;p&gt;I got my bachelor’s degree in pharmacy from Nankai University, and a master’s degree in computational biology from The University of Tokyo (Todai). At graduate school, I spent 2 wonderful years on research in algorithms for biological sequences alignment with &lt;a href=&quot;https://sites.google.com/site/frithbioinfo/home?authuser=0&quot;&gt;Prof. Frith&lt;/a&gt;. If you are interested in our research, please check our &lt;a href=&quot;https://www.biorxiv.org/content/10.1101/2021.01.25.428050v1&quot;&gt;paper&lt;/a&gt; on AICoB 2020 &amp;amp; 2021.&lt;/p&gt;

&lt;p&gt;I love the world of math, statistics, and computer science. I taught myself bits of knowledge on them to pass the graduate school entrance examination and get hired by my current company. You can find my self-learning journey &lt;a href=&quot;/biography/2021/05/14/my-journey-in-cs-and-math/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before COVID-19 situation, I love playing table tennis. Currently I spend my spare time relaxing, reading, learning, and chatting with my girlfriend. I miss her so much.&lt;/p&gt;
</description>
        <pubDate>Fri, 14 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biography/2021/05/14/about-me/</link>
        <guid isPermaLink="true">http://localhost:4000/biography/2021/05/14/about-me/</guid>
        
        <category>biography</category>
        
        
        <category>biography</category>
        
      </item>
    
  </channel>
</rss>
